import { useState, useEffect } from 'react'
import { TodoProvider } from './contexts'
import './App.css'
import TodoForm from './components/TodoForm'
import TodoItem from './components/TodoItem'

function App() {
  const [todos, setTodos] = useState([])

  /*

This line uses the useState hook to create a state variable todos initialized to an empty array [].
todos will hold the list of todo items.
setTodos is a function provided by React to update the value of todos.
  */

  const addTodo = (todo) => {
    setTodos((prev) => [{ id: Date.now(), ...todo }, ...prev])
  }

  /*
addTodo is a function that takes a todo object as an argument.
It uses the setTodos function to update the todos state.
The new todos array is constructed by spreading the existing prev todos and adding a new todo object with a unique ID generated by Date.now() and the properties of the todo object passed as an argument.
  */

  const updateTodo = (id, todo) => {
    setTodos((prev) => prev.map((prevTodo) => (prevTodo.id === id ? todo : prevTodo)))


  }

  /*
updateTodo is a function that takes an id and a todo object as arguments.
It uses the setTodos function to update the todos state.
It maps over the previous todos array (prev) and updates the todo item with the specified id with the new todo object.

  */

  const deleteTodo = (id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id))
  }

  /*
deleteTodo is a function that takes an id as an argument.
It uses the setTodos function to update the todos state.
It filters out the todo item with the specified id from the previous todos array (prev).
  */

  const toggleComplete = (id) => {
    //console.log(id);
    setTodos((prev) =>
      prev.map((prevTodo) =>
        prevTodo.id === id ? {
          ...prevTodo,
          completed: !prevTodo.completed
        } : prevTodo))
  }

  /*
toggleComplete is a function that takes an id as an argument.
It uses the setTodos function to update the todos state.
It maps over the previous todos array (prev) and toggles the completed property of the todo item with the specified id.
  */

/*

Syntax Explanation:

const addTodo = (todo) => { ... }: This syntax defines an arrow function named addTodo that takes a todo parameter. Arrow functions are a concise way to write functions in JavaScript.
setTodos((prev) => [...] ): This syntax uses the functional form of setTodos, where the previous state (prev) is passed as an argument to a function. This function returns the new state based on the previous state.
prev.map(...): This syntax utilizes the map function to iterate over elements of an array and return a new array with each element transformed based on a function.
{ ...prevTodo, completed: !prevTodo.completed }: This syntax uses the spread operator (...) to create a copy of the prevTodo object with the completed property toggled (!prevTodo.completed).
*/

  useEffect(() => {
    const todos = JSON.parse(localStorage.getItem("todos"))

    if (todos && todos.length > 0) {
      setTodos(todos)
    }
  }, [])

  /*
This useEffect is executed when the component mounts, as indicated by the empty dependency array ([]).
It retrieves the todo items stored in the local storage by accessing the "todos" key using localStorage.getItem("todos").
If there are todo items stored in the local storage (todos && todos.length > 0), they are parsed and set as the initial state using setTodos.
This ensures that if there are previously saved todos, they are loaded into the component's state when it mounts.
  */

  useEffect(() => {
    localStorage.setItem("todos", JSON.stringify(todos))
  }, [todos])


/*
This useEffect is executed whenever the todos state changes, as indicated by [todos] in the dependency array.
It stores the current state of todo items (todos) in the local storage under the key "todos" using localStorage.setItem.
This ensures that whenever the todos are modified (added, updated, deleted, or completed), the changes are persisted in the local storage.
Storing todos in local storage allows the application to remember the todos even after the page is refreshed or the browser is closed and reopened.

In summary, these useEffect calls are responsible for synchronizing the state of todo items with the local storage. The first useEffect loads todos from local storage when the component mounts, and the second useEffect saves todos to local storage whenever they change. This ensures that todo items are persisted between page sessions and provide a seamless user experience.
*/

  return (
    <TodoProvider value={{ todos, addTodo, updateTodo, deleteTodo, toggleComplete }}>
      {/* Wraps the entire JSX with TodoProvider, providing todo-related context to its descendants.
Passes down todos, addTodo, updateTodo, deleteTodo, and toggleComplete as context values. */}
      <div className="bg-[#172842] min-h-screen py-8">
        <div className="w-full max-w-2xl mx-auto shadow-md rounded-lg px-4 py-3 text-white">
          <h1 className="text-2xl font-bold text-center mb-8 mt-2">Manage Your Todos</h1>
          <div className="mb-4">
            {/* Todo form goes here */}
            <TodoForm />
          </div>
          <div className="flex flex-wrap gap-y-3">
            {/*Loop and Add TodoItem here */}
            {todos.map((todo) => (
              <div key={todo.id}
                className='w-full'
              >
                <TodoItem todo={todo} />
              </div>
              /*
Creates a container for displaying todo items in a flex layout.
Maps over the todos array, rendering a TodoItem component for each todo.
Each TodoItem component is wrapped in a div with a unique key.
              */
            ))}
          </div>
        </div>
      </div>
    </TodoProvider>
  )
}

/*

Reasoning and Effect on Application:
TodoProvider Context:

Reasoning: Wrapping the UI with TodoProvider ensures that all components within its hierarchy have access to todo-related context (i.e., todos, addTodo, updateTodo, deleteTodo, toggleComplete).
Effect on Application: This allows components such as TodoForm and TodoItem to easily interact with and modify todo data without needing to pass props down manually, promoting cleaner and more maintainable code.

*/

export default App